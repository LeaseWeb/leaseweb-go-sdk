/*
LeaseWeb API for IP address management

> The base URL for this API is: **https://api.leaseweb.com/ipMgmt/v2/_**

API version: v2
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package ips

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type IpsAPI interface {

	/*
	GetIP Inspect an IP

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param ip IP address or IP address with prefixLength {ip}_{prefix}. If prefixLength is not given, then we assume 32 (for IPv4) or 128 (for IPv6). PrefixLength is mandatory for IP range, for example, the IPv6 address range with prefixLength = 112
	@return ApiGetIPRequest
	*/
	GetIP(ctx context.Context, ip string) ApiGetIPRequest

	// GetIPExecute executes the request
	//  @return Ip
	GetIPExecute(r ApiGetIPRequest) (*Ip, *http.Response, error)

	/*
	GetIPList List IPs

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetIPListRequest
	*/
	GetIPList(ctx context.Context) ApiGetIPListRequest

	// GetIPListExecute executes the request
	//  @return GetIPListResult
	GetIPListExecute(r ApiGetIPListRequest) (*GetIPListResult, *http.Response, error)

	/*
	GetNullRouteHistory Inspect null route history

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Null route ID
	@return ApiGetNullRouteHistoryRequest
	*/
	GetNullRouteHistory(ctx context.Context, id string) ApiGetNullRouteHistoryRequest

	// GetNullRouteHistoryExecute executes the request
	//  @return NullRoutedIP
	GetNullRouteHistoryExecute(r ApiGetNullRouteHistoryRequest) (*NullRoutedIP, *http.Response, error)

	/*
	GetNullRouteHistoryList Inspect null route history

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetNullRouteHistoryListRequest
	*/
	GetNullRouteHistoryList(ctx context.Context) ApiGetNullRouteHistoryListRequest

	// GetNullRouteHistoryListExecute executes the request
	//  @return GetNullRouteHistoryListResult
	GetNullRouteHistoryListExecute(r ApiGetNullRouteHistoryListRequest) (*GetNullRouteHistoryListResult, *http.Response, error)

	/*
	GetReverseLookupRecordList List reverse lookup records for an IPv6 range

	Get reverse lookup values set for IPs in the specified range

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param ip IP address or IP address with prefixLength {ip}_{prefix}. If prefixLength is not given, then we assume 32 (for IPv4) or 128 (for IPv6). PrefixLength is mandatory for IP range, for example, the IPv6 address range with prefixLength = 112
	@return ApiGetReverseLookupRecordListRequest
	*/
	GetReverseLookupRecordList(ctx context.Context, ip string) ApiGetReverseLookupRecordListRequest

	// GetReverseLookupRecordListExecute executes the request
	//  @return GetReverseLookupRecordListResult
	GetReverseLookupRecordListExecute(r ApiGetReverseLookupRecordListRequest) (*GetReverseLookupRecordListResult, *http.Response, error)

	/*
	NullRouteIP Null route an IP

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param ip IP address or IP address with prefixLength {ip}_{prefix}. If prefixLength is not given, then we assume 32 (for IPv4) or 128 (for IPv6). PrefixLength is mandatory for IP range, for example, the IPv6 address range with prefixLength = 112
	@return ApiNullRouteIPRequest
	*/
	NullRouteIP(ctx context.Context, ip string) ApiNullRouteIPRequest

	// NullRouteIPExecute executes the request
	//  @return NullRoutedIP
	NullRouteIPExecute(r ApiNullRouteIPRequest) (*NullRoutedIP, *http.Response, error)

	/*
	RemoveIPNullRoute Remove a null route

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param ip IP address or IP address with prefixLength {ip}_{prefix}. If prefixLength is not given, then we assume 32 (for IPv4) or 128 (for IPv6). PrefixLength is mandatory for IP range, for example, the IPv6 address range with prefixLength = 112
	@return ApiRemoveIPNullRouteRequest
	*/
	RemoveIPNullRoute(ctx context.Context, ip string) ApiRemoveIPNullRouteRequest

	// RemoveIPNullRouteExecute executes the request
	RemoveIPNullRouteExecute(r ApiRemoveIPNullRouteRequest) (*http.Response, error)

	/*
	UpdateIP Update an IP

	Use this operation to set reverse lookup for IPv4 IP addresses.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param ip IP address or IP address with prefixLength {ip}_{prefix}. If prefixLength is not given, then we assume 32
	@return ApiUpdateIPRequest
	*/
	UpdateIP(ctx context.Context, ip string) ApiUpdateIPRequest

	// UpdateIPExecute executes the request
	//  @return Ip
	UpdateIPExecute(r ApiUpdateIPRequest) (*Ip, *http.Response, error)

	/*
	UpdateNullRoute Update a null route

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Null route ID
	@return ApiUpdateNullRouteRequest
	*/
	UpdateNullRoute(ctx context.Context, id string) ApiUpdateNullRouteRequest

	// UpdateNullRouteExecute executes the request
	//  @return NullRoutedIP
	UpdateNullRouteExecute(r ApiUpdateNullRouteRequest) (*NullRoutedIP, *http.Response, error)

	/*
	UpdateReverseLookupRecords Set or remove reverse lookup records for an IPv6 range

	This endpoint allows to set or unset reverse lookup for multiple IPv6 IPs in a specific IP range. To remove reverse lookup for an IP address set it to `null` or `""`.
Reverse lookup values of IPs not listed in the request body will not be affected.
You can set up to 20 records in a single request.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param ip IP address or IP address with prefixLength {ip}_{prefix}. If prefixLength is not given, then we assume 32 (for IPv4) or 128 (for IPv6). PrefixLength is mandatory for IP range, for example, the IPv6 address range with prefixLength = 112
	@return ApiUpdateReverseLookupRecordsRequest
	*/
	UpdateReverseLookupRecords(ctx context.Context, ip string) ApiUpdateReverseLookupRecordsRequest

	// UpdateReverseLookupRecordsExecute executes the request
	//  @return UpdateReverseLookupRecordsResult
	UpdateReverseLookupRecordsExecute(r ApiUpdateReverseLookupRecordsRequest) (*UpdateReverseLookupRecordsResult, *http.Response, error)
}

// IpsAPIService IpsAPI service
type IpsAPIService service

type ApiGetIPRequest struct {
	ctx context.Context
	ApiService IpsAPI
	ip string
}

func (r ApiGetIPRequest) Execute() (*Ip, *http.Response, error) {
	return r.ApiService.GetIPExecute(r)
}

/*
GetIP Inspect an IP

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ip IP address or IP address with prefixLength {ip}_{prefix}. If prefixLength is not given, then we assume 32 (for IPv4) or 128 (for IPv6). PrefixLength is mandatory for IP range, for example, the IPv6 address range with prefixLength = 112
 @return ApiGetIPRequest
*/
func (a *IpsAPIService) GetIP(ctx context.Context, ip string) ApiGetIPRequest {
	return ApiGetIPRequest{
		ApiService: a,
		ctx: ctx,
		ip: ip,
	}
}

// Execute executes the request
//  @return Ip
func (a *IpsAPIService) GetIPExecute(r ApiGetIPRequest) (*Ip, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Ip
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpsAPIService.GetIP")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ips/{ip}"
	localVarPath = strings.Replace(localVarPath, "{"+"ip"+"}", url.PathEscape(parameterValueToString(r.ip, "ip")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-LSW-Auth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-LSW-Auth"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIPListRequest struct {
	ctx context.Context
	ApiService IpsAPI
	limit *int32
	offset *int32
	subnetId *string
	version *ProtocolVersion
	type_ *IpType
	nullRouted *bool
	primary *bool
	fromIp *string
	toIp *string
	ips *string
	equipmentIds *string
	assignedContractIds *string
	sort *string
	reverseLookup *string
}

// Limit the number of results returned.
func (r ApiGetIPListRequest) Limit(limit int32) ApiGetIPListRequest {
	r.limit = &limit
	return r
}

// Return results starting from the given offset.
func (r ApiGetIPListRequest) Offset(offset int32) ApiGetIPListRequest {
	r.offset = &offset
	return r
}

// Filter by subnet
func (r ApiGetIPListRequest) SubnetId(subnetId string) ApiGetIPListRequest {
	r.subnetId = &subnetId
	return r
}

// Filter by protocol version
func (r ApiGetIPListRequest) Version(version ProtocolVersion) ApiGetIPListRequest {
	r.version = &version
	return r
}

// Filter by IP type
func (r ApiGetIPListRequest) Type_(type_ IpType) ApiGetIPListRequest {
	r.type_ = &type_
	return r
}

// Filter by whether or not the IP has an active null route (true or false)
func (r ApiGetIPListRequest) NullRouted(nullRouted bool) ApiGetIPListRequest {
	r.nullRouted = &nullRouted
	return r
}

// Filter by whether or not the IP is primary (true or false)
func (r ApiGetIPListRequest) Primary(primary bool) ApiGetIPListRequest {
	r.primary = &primary
	return r
}

// Return only IPs greater or equal to the specified address
func (r ApiGetIPListRequest) FromIp(fromIp string) ApiGetIPListRequest {
	r.fromIp = &fromIp
	return r
}

// Return only IPs lower or equal to the specified address
func (r ApiGetIPListRequest) ToIp(toIp string) ApiGetIPListRequest {
	r.toIp = &toIp
	return r
}

// Return only IPs specified as a comma-separated list
func (r ApiGetIPListRequest) Ips(ips string) ApiGetIPListRequest {
	r.ips = &ips
	return r
}

// Return only IPs assigned to equipment items specified as a comma-separated list of IDs
func (r ApiGetIPListRequest) EquipmentIds(equipmentIds string) ApiGetIPListRequest {
	r.equipmentIds = &equipmentIds
	return r
}

// Return only IPs assigned to contracts specified as a comma-separated list of IDs
func (r ApiGetIPListRequest) AssignedContractIds(assignedContractIds string) ApiGetIPListRequest {
	r.assignedContractIds = &assignedContractIds
	return r
}

// Comma-separated list of sort field names. Prepend the field name with &#39;-&#39; for descending order. E.g. &#x60;sort&#x3D;ip,-nullrouted&#x60;. Sortable field names are ip, nullRouted, reverseLookup.
func (r ApiGetIPListRequest) Sort(sort string) ApiGetIPListRequest {
	r.sort = &sort
	return r
}

// Filter by reverse lookup.
func (r ApiGetIPListRequest) ReverseLookup(reverseLookup string) ApiGetIPListRequest {
	r.reverseLookup = &reverseLookup
	return r
}

func (r ApiGetIPListRequest) Execute() (*GetIPListResult, *http.Response, error) {
	return r.ApiService.GetIPListExecute(r)
}

/*
GetIPList List IPs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetIPListRequest
*/
func (a *IpsAPIService) GetIPList(ctx context.Context) ApiGetIPListRequest {
	return ApiGetIPListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetIPListResult
func (a *IpsAPIService) GetIPListExecute(r ApiGetIPListRequest) (*GetIPListResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetIPListResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpsAPIService.GetIPList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ips"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.subnetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subnetId", r.subnetId, "form", "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.nullRouted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nullRouted", r.nullRouted, "form", "")
	}
	if r.primary != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "primary", r.primary, "form", "")
	}
	if r.fromIp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromIp", r.fromIp, "form", "")
	}
	if r.toIp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toIp", r.toIp, "form", "")
	}
	if r.ips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ips", r.ips, "form", "")
	}
	if r.equipmentIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "equipmentIds", r.equipmentIds, "form", "")
	}
	if r.assignedContractIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assignedContractIds", r.assignedContractIds, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.reverseLookup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reverseLookup", r.reverseLookup, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-LSW-Auth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-LSW-Auth"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNullRouteHistoryRequest struct {
	ctx context.Context
	ApiService IpsAPI
	id string
}

func (r ApiGetNullRouteHistoryRequest) Execute() (*NullRoutedIP, *http.Response, error) {
	return r.ApiService.GetNullRouteHistoryExecute(r)
}

/*
GetNullRouteHistory Inspect null route history

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Null route ID
 @return ApiGetNullRouteHistoryRequest
*/
func (a *IpsAPIService) GetNullRouteHistory(ctx context.Context, id string) ApiGetNullRouteHistoryRequest {
	return ApiGetNullRouteHistoryRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return NullRoutedIP
func (a *IpsAPIService) GetNullRouteHistoryExecute(r ApiGetNullRouteHistoryRequest) (*NullRoutedIP, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NullRoutedIP
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpsAPIService.GetNullRouteHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nullRoutes/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-LSW-Auth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-LSW-Auth"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNullRouteHistoryListRequest struct {
	ctx context.Context
	ApiService IpsAPI
	limit *int32
	offset *int32
	fromIp *string
	toIp *string
	fromDate *string
	toDate *string
	nulledBy *string
	unnulledBy *string
	ticketId *string
	contractId *string
	equipmentId *string
	sort *string
}

// Limit the number of results returned.
func (r ApiGetNullRouteHistoryListRequest) Limit(limit int32) ApiGetNullRouteHistoryListRequest {
	r.limit = &limit
	return r
}

// Return results starting from the given offset.
func (r ApiGetNullRouteHistoryListRequest) Offset(offset int32) ApiGetNullRouteHistoryListRequest {
	r.offset = &offset
	return r
}

// Return only IPs greater or equal to the specified address
func (r ApiGetNullRouteHistoryListRequest) FromIp(fromIp string) ApiGetNullRouteHistoryListRequest {
	r.fromIp = &fromIp
	return r
}

// Return only IPs lower or equal to the specified address
func (r ApiGetNullRouteHistoryListRequest) ToIp(toIp string) ApiGetNullRouteHistoryListRequest {
	r.toIp = &toIp
	return r
}

// Return only null routes active after the specified date and time
func (r ApiGetNullRouteHistoryListRequest) FromDate(fromDate string) ApiGetNullRouteHistoryListRequest {
	r.fromDate = &fromDate
	return r
}

// Return only null routes active before the specified date and time
func (r ApiGetNullRouteHistoryListRequest) ToDate(toDate string) ApiGetNullRouteHistoryListRequest {
	r.toDate = &toDate
	return r
}

// Filter by the email address of the user who created the null route
func (r ApiGetNullRouteHistoryListRequest) NulledBy(nulledBy string) ApiGetNullRouteHistoryListRequest {
	r.nulledBy = &nulledBy
	return r
}

// Filter by the email address of the user who removed the null route
func (r ApiGetNullRouteHistoryListRequest) UnnulledBy(unnulledBy string) ApiGetNullRouteHistoryListRequest {
	r.unnulledBy = &unnulledBy
	return r
}

// Filter by the reference stored with the null route
func (r ApiGetNullRouteHistoryListRequest) TicketId(ticketId string) ApiGetNullRouteHistoryListRequest {
	r.ticketId = &ticketId
	return r
}

// Filter by ID of the contract assigned to the IP at the time of null route creation
func (r ApiGetNullRouteHistoryListRequest) ContractId(contractId string) ApiGetNullRouteHistoryListRequest {
	r.contractId = &contractId
	return r
}

// Filter by ID of the server assigned to the IP at the time of null route creation
func (r ApiGetNullRouteHistoryListRequest) EquipmentId(equipmentId string) ApiGetNullRouteHistoryListRequest {
	r.equipmentId = &equipmentId
	return r
}

// Comma-separated list of sort field names. Prepend the field name with &#39;-&#39; for descending order. E.g. &#x60;sort&#x3D;ip,-nullrouted&#x60;. Sortable field names are ip, nullRouted, reverseLookup.
func (r ApiGetNullRouteHistoryListRequest) Sort(sort string) ApiGetNullRouteHistoryListRequest {
	r.sort = &sort
	return r
}

func (r ApiGetNullRouteHistoryListRequest) Execute() (*GetNullRouteHistoryListResult, *http.Response, error) {
	return r.ApiService.GetNullRouteHistoryListExecute(r)
}

/*
GetNullRouteHistoryList Inspect null route history

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetNullRouteHistoryListRequest
*/
func (a *IpsAPIService) GetNullRouteHistoryList(ctx context.Context) ApiGetNullRouteHistoryListRequest {
	return ApiGetNullRouteHistoryListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetNullRouteHistoryListResult
func (a *IpsAPIService) GetNullRouteHistoryListExecute(r ApiGetNullRouteHistoryListRequest) (*GetNullRouteHistoryListResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetNullRouteHistoryListResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpsAPIService.GetNullRouteHistoryList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nullRoutes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.fromIp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromIp", r.fromIp, "form", "")
	}
	if r.toIp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toIp", r.toIp, "form", "")
	}
	if r.fromDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromDate", r.fromDate, "form", "")
	}
	if r.toDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toDate", r.toDate, "form", "")
	}
	if r.nulledBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nulledBy", r.nulledBy, "form", "")
	}
	if r.unnulledBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unnulledBy", r.unnulledBy, "form", "")
	}
	if r.ticketId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketId", r.ticketId, "form", "")
	}
	if r.contractId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contractId", r.contractId, "form", "")
	}
	if r.equipmentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "equipmentId", r.equipmentId, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-LSW-Auth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-LSW-Auth"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReverseLookupRecordListRequest struct {
	ctx context.Context
	ApiService IpsAPI
	ip string
	reverseLookup *string
	limit *int32
	offset *int32
}

// Filter by reverse lookup.
func (r ApiGetReverseLookupRecordListRequest) ReverseLookup(reverseLookup string) ApiGetReverseLookupRecordListRequest {
	r.reverseLookup = &reverseLookup
	return r
}

// Limit the number of results returned.
func (r ApiGetReverseLookupRecordListRequest) Limit(limit int32) ApiGetReverseLookupRecordListRequest {
	r.limit = &limit
	return r
}

// Return results starting from the given offset.
func (r ApiGetReverseLookupRecordListRequest) Offset(offset int32) ApiGetReverseLookupRecordListRequest {
	r.offset = &offset
	return r
}

func (r ApiGetReverseLookupRecordListRequest) Execute() (*GetReverseLookupRecordListResult, *http.Response, error) {
	return r.ApiService.GetReverseLookupRecordListExecute(r)
}

/*
GetReverseLookupRecordList List reverse lookup records for an IPv6 range

Get reverse lookup values set for IPs in the specified range

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ip IP address or IP address with prefixLength {ip}_{prefix}. If prefixLength is not given, then we assume 32 (for IPv4) or 128 (for IPv6). PrefixLength is mandatory for IP range, for example, the IPv6 address range with prefixLength = 112
 @return ApiGetReverseLookupRecordListRequest
*/
func (a *IpsAPIService) GetReverseLookupRecordList(ctx context.Context, ip string) ApiGetReverseLookupRecordListRequest {
	return ApiGetReverseLookupRecordListRequest{
		ApiService: a,
		ctx: ctx,
		ip: ip,
	}
}

// Execute executes the request
//  @return GetReverseLookupRecordListResult
func (a *IpsAPIService) GetReverseLookupRecordListExecute(r ApiGetReverseLookupRecordListRequest) (*GetReverseLookupRecordListResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetReverseLookupRecordListResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpsAPIService.GetReverseLookupRecordList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ips/{ip}/reverseLookup"
	localVarPath = strings.Replace(localVarPath, "{"+"ip"+"}", url.PathEscape(parameterValueToString(r.ip, "ip")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.reverseLookup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reverseLookup", r.reverseLookup, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-LSW-Auth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-LSW-Auth"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiNullRouteIPRequest struct {
	ctx context.Context
	ApiService IpsAPI
	ip string
	nullRouteIPOpts *NullRouteIPOpts
}

// 
func (r ApiNullRouteIPRequest) NullRouteIPOpts(nullRouteIPOpts NullRouteIPOpts) ApiNullRouteIPRequest {
	r.nullRouteIPOpts = &nullRouteIPOpts
	return r
}

func (r ApiNullRouteIPRequest) Execute() (*NullRoutedIP, *http.Response, error) {
	return r.ApiService.NullRouteIPExecute(r)
}

/*
NullRouteIP Null route an IP

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ip IP address or IP address with prefixLength {ip}_{prefix}. If prefixLength is not given, then we assume 32 (for IPv4) or 128 (for IPv6). PrefixLength is mandatory for IP range, for example, the IPv6 address range with prefixLength = 112
 @return ApiNullRouteIPRequest
*/
func (a *IpsAPIService) NullRouteIP(ctx context.Context, ip string) ApiNullRouteIPRequest {
	return ApiNullRouteIPRequest{
		ApiService: a,
		ctx: ctx,
		ip: ip,
	}
}

// Execute executes the request
//  @return NullRoutedIP
func (a *IpsAPIService) NullRouteIPExecute(r ApiNullRouteIPRequest) (*NullRoutedIP, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NullRoutedIP
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpsAPIService.NullRouteIP")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ips/{ip}/nullRoute"
	localVarPath = strings.Replace(localVarPath, "{"+"ip"+"}", url.PathEscape(parameterValueToString(r.ip, "ip")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.nullRouteIPOpts
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-LSW-Auth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-LSW-Auth"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveIPNullRouteRequest struct {
	ctx context.Context
	ApiService IpsAPI
	ip string
}

func (r ApiRemoveIPNullRouteRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveIPNullRouteExecute(r)
}

/*
RemoveIPNullRoute Remove a null route

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ip IP address or IP address with prefixLength {ip}_{prefix}. If prefixLength is not given, then we assume 32 (for IPv4) or 128 (for IPv6). PrefixLength is mandatory for IP range, for example, the IPv6 address range with prefixLength = 112
 @return ApiRemoveIPNullRouteRequest
*/
func (a *IpsAPIService) RemoveIPNullRoute(ctx context.Context, ip string) ApiRemoveIPNullRouteRequest {
	return ApiRemoveIPNullRouteRequest{
		ApiService: a,
		ctx: ctx,
		ip: ip,
	}
}

// Execute executes the request
func (a *IpsAPIService) RemoveIPNullRouteExecute(r ApiRemoveIPNullRouteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpsAPIService.RemoveIPNullRoute")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ips/{ip}/nullRoute"
	localVarPath = strings.Replace(localVarPath, "{"+"ip"+"}", url.PathEscape(parameterValueToString(r.ip, "ip")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-LSW-Auth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-LSW-Auth"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateIPRequest struct {
	ctx context.Context
	ApiService IpsAPI
	ip string
	updateIPOpts *UpdateIPOpts
}

func (r ApiUpdateIPRequest) UpdateIPOpts(updateIPOpts UpdateIPOpts) ApiUpdateIPRequest {
	r.updateIPOpts = &updateIPOpts
	return r
}

func (r ApiUpdateIPRequest) Execute() (*Ip, *http.Response, error) {
	return r.ApiService.UpdateIPExecute(r)
}

/*
UpdateIP Update an IP

Use this operation to set reverse lookup for IPv4 IP addresses.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ip IP address or IP address with prefixLength {ip}_{prefix}. If prefixLength is not given, then we assume 32
 @return ApiUpdateIPRequest
*/
func (a *IpsAPIService) UpdateIP(ctx context.Context, ip string) ApiUpdateIPRequest {
	return ApiUpdateIPRequest{
		ApiService: a,
		ctx: ctx,
		ip: ip,
	}
}

// Execute executes the request
//  @return Ip
func (a *IpsAPIService) UpdateIPExecute(r ApiUpdateIPRequest) (*Ip, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Ip
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpsAPIService.UpdateIP")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ips/{ip}"
	localVarPath = strings.Replace(localVarPath, "{"+"ip"+"}", url.PathEscape(parameterValueToString(r.ip, "ip")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateIPOpts
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-LSW-Auth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-LSW-Auth"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateNullRouteRequest struct {
	ctx context.Context
	ApiService IpsAPI
	id string
	updateNullRouteOpts *UpdateNullRouteOpts
}

func (r ApiUpdateNullRouteRequest) UpdateNullRouteOpts(updateNullRouteOpts UpdateNullRouteOpts) ApiUpdateNullRouteRequest {
	r.updateNullRouteOpts = &updateNullRouteOpts
	return r
}

func (r ApiUpdateNullRouteRequest) Execute() (*NullRoutedIP, *http.Response, error) {
	return r.ApiService.UpdateNullRouteExecute(r)
}

/*
UpdateNullRoute Update a null route

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Null route ID
 @return ApiUpdateNullRouteRequest
*/
func (a *IpsAPIService) UpdateNullRoute(ctx context.Context, id string) ApiUpdateNullRouteRequest {
	return ApiUpdateNullRouteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return NullRoutedIP
func (a *IpsAPIService) UpdateNullRouteExecute(r ApiUpdateNullRouteRequest) (*NullRoutedIP, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NullRoutedIP
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpsAPIService.UpdateNullRoute")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nullRoutes/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateNullRouteOpts
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-LSW-Auth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-LSW-Auth"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateReverseLookupRecordsRequest struct {
	ctx context.Context
	ApiService IpsAPI
	ip string
	updateReverseLookupRecordsOpts *UpdateReverseLookupRecordsOpts
}

func (r ApiUpdateReverseLookupRecordsRequest) UpdateReverseLookupRecordsOpts(updateReverseLookupRecordsOpts UpdateReverseLookupRecordsOpts) ApiUpdateReverseLookupRecordsRequest {
	r.updateReverseLookupRecordsOpts = &updateReverseLookupRecordsOpts
	return r
}

func (r ApiUpdateReverseLookupRecordsRequest) Execute() (*UpdateReverseLookupRecordsResult, *http.Response, error) {
	return r.ApiService.UpdateReverseLookupRecordsExecute(r)
}

/*
UpdateReverseLookupRecords Set or remove reverse lookup records for an IPv6 range

This endpoint allows to set or unset reverse lookup for multiple IPv6 IPs in a specific IP range. To remove reverse lookup for an IP address set it to `null` or `""`.
Reverse lookup values of IPs not listed in the request body will not be affected.
You can set up to 20 records in a single request.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ip IP address or IP address with prefixLength {ip}_{prefix}. If prefixLength is not given, then we assume 32 (for IPv4) or 128 (for IPv6). PrefixLength is mandatory for IP range, for example, the IPv6 address range with prefixLength = 112
 @return ApiUpdateReverseLookupRecordsRequest
*/
func (a *IpsAPIService) UpdateReverseLookupRecords(ctx context.Context, ip string) ApiUpdateReverseLookupRecordsRequest {
	return ApiUpdateReverseLookupRecordsRequest{
		ApiService: a,
		ctx: ctx,
		ip: ip,
	}
}

// Execute executes the request
//  @return UpdateReverseLookupRecordsResult
func (a *IpsAPIService) UpdateReverseLookupRecordsExecute(r ApiUpdateReverseLookupRecordsRequest) (*UpdateReverseLookupRecordsResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateReverseLookupRecordsResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpsAPIService.UpdateReverseLookupRecords")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ips/{ip}/reverseLookup"
	localVarPath = strings.Replace(localVarPath, "{"+"ip"+"}", url.PathEscape(parameterValueToString(r.ip, "ip")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateReverseLookupRecordsOpts
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-LSW-Auth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-LSW-Auth"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
